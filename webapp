# trading_phantom/webapp.py

import logging
import os
import subprocess
import sys
import threading
import uuid

from flask import Flask, jsonify, render_template, request

from trading_phantom.backtest.run_and_visual import run_backtest_and_visual

logger = logging.getLogger(__name__)

app = Flask(__name__, template_folder=os.path.join(os.path.dirname(__file__), 'templates'), static_folder=os.path.join(os.path.dirname(__file__), 'static'))

# Simple in-memory job store for backtests
_backtest_jobs = {}

# Bot subprocess handle
_bot_process = None
_bot_lock = threading.Lock()


@app.route('/')
def index():
    return render_template('index.html')


@app.route('/info/ml')
def info_ml():
    return render_template('ml_info.html')


@app.route('/api/backtest', methods=['POST'])
def start_backtest():
    """Inicia un backtest en background y devuelve un job_id."""
    data = request.get_json() or {}
    symbol = data.get('symbol')
    timeframe = data.get('timeframe')
    bars = data.get('bars', 1000)
    sma = data.get('sma_period', 50)
    rsi = data.get('rsi_period', 14)

    job_id = str(uuid.uuid4())
    _backtest_jobs[job_id] = {'status': 'running', 'result': None}

    def _make_jsonable(o):
        # Convert common non-json-serializable objects to plain Python types
        try:
            import numpy as _np
            import pandas as _pd
        except Exception:
            _np = None
            _pd = None

        # namedtuple-like _asdict
        if hasattr(o, '_asdict') and callable(o._asdict):
            try:
                return _make_jsonable(o._asdict())
            except Exception:
                return str(o)

        if _pd is not None and isinstance(o, _pd.Series):
            return _make_jsonable(o.to_dict())
        if _pd is not None and isinstance(o, _pd.DataFrame):
            return _make_jsonable(o.to_dict(orient='list'))

        if _np is not None and isinstance(o, _np.generic):
            return o.item()
        if isinstance(o, dict):
            return {str(k): _make_jsonable(v) for k, v in o.items()}
        if isinstance(o, (list, tuple, set)):
            return [_make_jsonable(v) for v in o]
        # fallback for basic serializables
        if isinstance(o, (str, int, float, bool)) or o is None:
            return o
        # last resort: try to convert to string
        try:
            return str(o)
        except Exception:
            return None

    def worker():
        try:
            res = run_backtest_and_visual(symbol or "EURUSD-T", bars=bars, sma_period=sma, rsi_period=rsi, run_plot=False)
            safe = _make_jsonable(res)
            _backtest_jobs[job_id]['status'] = 'done'
            _backtest_jobs[job_id]['result'] = safe
        except Exception as e:
            logger.exception("Error running backtest")
            _backtest_jobs[job_id]['status'] = 'error'
            _backtest_jobs[job_id]['result'] = {'error': str(e)}

    t = threading.Thread(target=worker, daemon=True)
    t.start()

    return jsonify({'job_id': job_id})


@app.route('/api/backtest/<job_id>', methods=['GET'])
def backtest_status(job_id):
    job = _backtest_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'job not found'}), 404
    return jsonify(job)


@app.route('/api/bot/start', methods=['POST'])
def bot_start():
    """Arranca el orquestador (`python -m trading_phantom.main`) como subprocess y redirige su salida a `logs/bot.log`"""
    global _bot_process
    with _bot_lock:
        if _bot_process is not None and _bot_process.poll() is None:
            return jsonify({'status': 'already_running', 'pid': _bot_process.pid})

        body = request.get_json() or {}
        args = [sys.executable, '-m', 'trading_phantom.main']
        if body.get('debug'):
            args.append('--debug')
        if body.get('iterations'):
            args += ['--iterations', str(body['iterations'])]

        # Ensure logs directory exists
        logs_dir = os.path.join(os.path.dirname(__file__), '..', 'logs')
        try:
            os.makedirs(logs_dir, exist_ok=True)
        except Exception:
            logger.exception('Failed to create logs directory')

        bot_log = os.path.join(logs_dir, 'bot.log')

        # Start process and forward stdout/stderr to bot.log
        try:
            proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
        except Exception as e:
            logger.exception('Failed to start bot subprocess')
            return jsonify({'status': 'error', 'error': str(e)}), 500

        # Helper thread to consume stdout and append to bot.log
        def _forward_output_to_log(pipe, logfile_path):
            try:
                with open(logfile_path, 'a', encoding='utf-8') as fh:
                    for line in pipe:
                        fh.write(line)
                        fh.flush()
            except Exception:
                logger.exception('Error while forwarding bot output to log')

        t = threading.Thread(target=_forward_output_to_log, args=(proc.stdout, bot_log), daemon=True)
        t.start()

        _bot_process = proc
        logger.info('Started bot subprocess pid=%s; logging to %s', _bot_process.pid, bot_log)
        return jsonify({'status': 'started', 'pid': _bot_process.pid})


@app.route('/api/bot/stop', methods=['POST'])
def bot_stop():
    global _bot_process
    with _bot_lock:
        if _bot_process is None or _bot_process.poll() is not None:
            return jsonify({'status': 'not_running'})
        _bot_process.terminate()
        try:
            _bot_process.wait(timeout=5)
        except Exception:
            _bot_process.kill()
        pid = _bot_process.pid
        _bot_process = None
        logger.info('Stopped bot subprocess pid=%s', pid)
        return jsonify({'status': 'stopped', 'pid': pid})


@app.route('/api/shutdown', methods=['POST'])
def shutdown():
    """Cierra el bot, la BD y detiene el servidor Flask."""
    def _do_shutdown():
        import time
        time.sleep(0.5)  # Dar tiempo a responder

        # Detener bot si está corriendo
        global _bot_process
        with _bot_lock:
            if _bot_process is not None and _bot_process.poll() is None:
                try:
                    _bot_process.terminate()
                    _bot_process.wait(timeout=3)
                except Exception:
                    try:
                        _bot_process.kill()
                    except Exception:
                        pass

        # Cerrar BD si existe
        try:
            from trading_phantom.analytics.db import get_db_session, engine
            session = get_db_session()
            if session:
                session.close()
            if engine:
                engine.dispose()
        except Exception as e:
            logger.exception('Error closing database')

        # Terminar Flask
        import os
        os._exit(0)

    t = threading.Thread(target=_do_shutdown, daemon=True)
    t.start()
    return jsonify({'status': 'shutting_down'})


@app.route('/api/bot/status', methods=['GET'])
def bot_status():
    global _bot_process
    with _bot_lock:
        if _bot_process is None or _bot_process.poll() is not None:
            return jsonify({'running': False})
        return jsonify({'running': True, 'pid': _bot_process.pid})


@app.route('/api/logs', methods=['GET'])
def get_logs():
    """Devuelve el contenido del archivo de logs si existe (últimas N líneas).

    Query parameters:
      - lines: number of lines to return (default 200)
      - bot: if truthy, return logs/bot.log specifically
      - file: optional exact filename (sanitized) within logs dir
    """
    lines = int(request.args.get('lines', 200))
    want_bot = request.args.get('bot', '').lower() in ('1', 'true', 'yes')
    file_name = request.args.get('file')
    logs_dir = os.path.join(os.path.dirname(__file__), '..', 'logs')

    if not os.path.isdir(logs_dir):
        return jsonify({'logs': ''})

    log_file = None
    if want_bot:
        candidate = os.path.join(logs_dir, 'bot.log')
        if os.path.exists(candidate):
            log_file = candidate
    if not log_file and file_name:
        # sanitize: avoid path traversal
        safe = os.path.basename(file_name)
        candidate = os.path.join(logs_dir, safe)
        if os.path.exists(candidate):
            log_file = candidate
    if not log_file:
        # fallback: pick most recently modified .log file
        logs = [os.path.join(logs_dir, f) for f in os.listdir(logs_dir) if f.endswith('.log')]
        if not logs:
            return jsonify({'logs': ''})
        logs.sort(key=lambda p: os.path.getmtime(p), reverse=True)
        log_file = logs[0]

    try:
        with open(log_file, 'r', encoding='utf-8') as fh:
            data = fh.readlines()
        return jsonify({'logs': ''.join(data[-lines:])})
    except Exception:
        logger.exception('Failed to read log file')
        return jsonify({'logs': ''})


def run_app(host='127.0.0.1', port=5000, debug=False):
    # Run the Flask app (used by launcher and for local testing)
    app.run(host=host, port=port, debug=debug, threaded=True)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    run_app()
